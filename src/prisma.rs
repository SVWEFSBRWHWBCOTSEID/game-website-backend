// Code generated by Prisma Client Rust. DO NOT EDIT
#![allow(unused_imports)]
#![allow(dead_code)]

pub static DATAMODEL_STR: &'static str =
    include_str!("/home/kepler/Documents/code/game-backend/prisma/schema.prisma");
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod game {
    use super::_prisma::*;
    pub const NAME: &str = "Game";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(super::_prisma::read_filters::StringFilter),
        CreatedAt(super::_prisma::read_filters::DateTimeFilter),
        Rated(super::_prisma::read_filters::BooleanFilter),
        GameKey(super::_prisma::read_filters::StringFilter),
        GameName(super::_prisma::read_filters::StringFilter),
        ClockInitial(super::_prisma::read_filters::IntNullableFilter),
        ClockIncrement(super::_prisma::read_filters::IntNullableFilter),
        FirstName(super::_prisma::read_filters::StringNullableFilter),
        FirstProvisional(super::_prisma::read_filters::BooleanNullableFilter),
        FirstRating(super::_prisma::read_filters::IntNullableFilter),
        SecondName(super::_prisma::read_filters::StringNullableFilter),
        SecondProvisional(super::_prisma::read_filters::BooleanNullableFilter),
        SecondRating(super::_prisma::read_filters::IntNullableFilter),
        RatingMin(super::_prisma::read_filters::IntFilter),
        RatingMax(super::_prisma::read_filters::IntFilter),
        StartPos(super::_prisma::read_filters::StringNullableFilter),
        Moves(super::_prisma::read_filters::StringFilter),
        FirstTime(super::_prisma::read_filters::IntNullableFilter),
        SecondTime(super::_prisma::read_filters::IntNullableFilter),
        Status(super::_prisma::read_filters::GameStatusFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Rated(value) => (rated::NAME, value.into()),
                Self::GameKey(value) => (game_key::NAME, value.into()),
                Self::GameName(value) => (game_name::NAME, value.into()),
                Self::ClockInitial(value) => (clock_initial::NAME, value.into()),
                Self::ClockIncrement(value) => (clock_increment::NAME, value.into()),
                Self::FirstName(value) => (first_name::NAME, value.into()),
                Self::FirstProvisional(value) => (first_provisional::NAME, value.into()),
                Self::FirstRating(value) => (first_rating::NAME, value.into()),
                Self::SecondName(value) => (second_name::NAME, value.into()),
                Self::SecondProvisional(value) => (second_provisional::NAME, value.into()),
                Self::SecondRating(value) => (second_rating::NAME, value.into()),
                Self::RatingMin(value) => (rating_min::NAME, value.into()),
                Self::RatingMax(value) => (rating_max::NAME, value.into()),
                Self::StartPos(value) => (start_pos::NAME, value.into()),
                Self::Moves(value) => (moves::NAME, value.into()),
                Self::FirstTime(value) => (first_time::NAME, value.into()),
                Self::SecondTime(value) => (second_time::NAME, value.into()),
                Self::Status(value) => (status::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(super::_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Id(super::SortOrder),
        CreatedAt(super::SortOrder),
        Rated(super::SortOrder),
        GameKey(super::SortOrder),
        GameName(super::SortOrder),
        ClockInitial(super::SortOrder),
        ClockIncrement(super::SortOrder),
        FirstName(super::SortOrder),
        FirstProvisional(super::SortOrder),
        FirstRating(super::SortOrder),
        SecondName(super::SortOrder),
        SecondProvisional(super::SortOrder),
        SecondRating(super::SortOrder),
        RatingMin(super::SortOrder),
        RatingMax(super::SortOrder),
        StartPos(super::SortOrder),
        Moves(super::SortOrder),
        FirstTime(super::SortOrder),
        SecondTime(super::SortOrder),
        Status(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(param) => ("id", param.into()),
                Self::CreatedAt(param) => ("createdAt", param.into()),
                Self::Rated(param) => ("rated", param.into()),
                Self::GameKey(param) => ("gameKey", param.into()),
                Self::GameName(param) => ("gameName", param.into()),
                Self::ClockInitial(param) => ("clockInitial", param.into()),
                Self::ClockIncrement(param) => ("clockIncrement", param.into()),
                Self::FirstName(param) => ("firstName", param.into()),
                Self::FirstProvisional(param) => ("firstProvisional", param.into()),
                Self::FirstRating(param) => ("firstRating", param.into()),
                Self::SecondName(param) => ("secondName", param.into()),
                Self::SecondProvisional(param) => ("secondProvisional", param.into()),
                Self::SecondRating(param) => ("secondRating", param.into()),
                Self::RatingMin(param) => ("ratingMin", param.into()),
                Self::RatingMax(param) => ("ratingMax", param.into()),
                Self::StartPos(param) => ("startPos", param.into()),
                Self::Moves(param) => ("moves", param.into()),
                Self::FirstTime(param) => ("firstTime", param.into()),
                Self::SecondTime(param) => ("secondTime", param.into()),
                Self::Status(param) => ("status", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Id(super::_prisma::write_params::StringParam),
        CreatedAt(super::_prisma::write_params::DateTimeParam),
        Rated(super::_prisma::write_params::BooleanParam),
        GameKey(super::_prisma::write_params::StringParam),
        GameName(super::_prisma::write_params::StringParam),
        ClockInitial(super::_prisma::write_params::IntNullableParam),
        ClockIncrement(super::_prisma::write_params::IntNullableParam),
        FirstName(super::_prisma::write_params::StringNullableParam),
        FirstProvisional(super::_prisma::write_params::BooleanNullableParam),
        FirstRating(super::_prisma::write_params::IntNullableParam),
        SecondName(super::_prisma::write_params::StringNullableParam),
        SecondProvisional(super::_prisma::write_params::BooleanNullableParam),
        SecondRating(super::_prisma::write_params::IntNullableParam),
        RatingMin(super::_prisma::write_params::IntParam),
        RatingMax(super::_prisma::write_params::IntParam),
        StartPos(super::_prisma::write_params::StringNullableParam),
        Moves(super::_prisma::write_params::StringParam),
        FirstTime(super::_prisma::write_params::IntNullableParam),
        SecondTime(super::_prisma::write_params::IntNullableParam),
        Status(super::_prisma::write_params::GameStatusParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Rated(value) => (rated::NAME, value.into()),
                Self::GameKey(value) => (game_key::NAME, value.into()),
                Self::GameName(value) => (game_name::NAME, value.into()),
                Self::ClockInitial(value) => (clock_initial::NAME, value.into()),
                Self::ClockIncrement(value) => (clock_increment::NAME, value.into()),
                Self::FirstName(value) => (first_name::NAME, value.into()),
                Self::FirstProvisional(value) => (first_provisional::NAME, value.into()),
                Self::FirstRating(value) => (first_rating::NAME, value.into()),
                Self::SecondName(value) => (second_name::NAME, value.into()),
                Self::SecondProvisional(value) => (second_provisional::NAME, value.into()),
                Self::SecondRating(value) => (second_rating::NAME, value.into()),
                Self::RatingMin(value) => (rating_min::NAME, value.into()),
                Self::RatingMax(value) => (rating_max::NAME, value.into()),
                Self::StartPos(value) => (start_pos::NAME, value.into()),
                Self::Moves(value) => (moves::NAME, value.into()),
                Self::FirstTime(value) => (first_time::NAME, value.into()),
                Self::SecondTime(value) => (second_time::NAME, value.into()),
                Self::Status(value) => (status::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Id(super::_prisma::write_params::StringParam),
        CreatedAt(super::_prisma::write_params::DateTimeParam),
        Rated(super::_prisma::write_params::BooleanParam),
        GameKey(super::_prisma::write_params::StringParam),
        GameName(super::_prisma::write_params::StringParam),
        ClockInitial(super::_prisma::write_params::IntNullableParam),
        ClockIncrement(super::_prisma::write_params::IntNullableParam),
        FirstName(super::_prisma::write_params::StringNullableParam),
        FirstProvisional(super::_prisma::write_params::BooleanNullableParam),
        FirstRating(super::_prisma::write_params::IntNullableParam),
        SecondName(super::_prisma::write_params::StringNullableParam),
        SecondProvisional(super::_prisma::write_params::BooleanNullableParam),
        SecondRating(super::_prisma::write_params::IntNullableParam),
        RatingMin(super::_prisma::write_params::IntParam),
        RatingMax(super::_prisma::write_params::IntParam),
        StartPos(super::_prisma::write_params::StringNullableParam),
        Moves(super::_prisma::write_params::StringParam),
        FirstTime(super::_prisma::write_params::IntNullableParam),
        SecondTime(super::_prisma::write_params::IntNullableParam),
        Status(super::_prisma::write_params::GameStatusParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Id(value) => ("id", value.into()),
                Self::CreatedAt(value) => ("createdAt", value.into()),
                Self::Rated(value) => ("rated", value.into()),
                Self::GameKey(value) => ("gameKey", value.into()),
                Self::GameName(value) => ("gameName", value.into()),
                Self::ClockInitial(value) => ("clockInitial", value.into()),
                Self::ClockIncrement(value) => ("clockIncrement", value.into()),
                Self::FirstName(value) => ("firstName", value.into()),
                Self::FirstProvisional(value) => ("firstProvisional", value.into()),
                Self::FirstRating(value) => ("firstRating", value.into()),
                Self::SecondName(value) => ("secondName", value.into()),
                Self::SecondProvisional(value) => ("secondProvisional", value.into()),
                Self::SecondRating(value) => ("secondRating", value.into()),
                Self::RatingMin(value) => ("ratingMin", value.into()),
                Self::RatingMax(value) => ("ratingMax", value.into()),
                Self::StartPos(value) => ("startPos", value.into()),
                Self::Moves(value) => ("moves", value.into()),
                Self::FirstTime(value) => ("firstTime", value.into()),
                Self::SecondTime(value) => ("secondTime", value.into()),
                Self::Status(value) => ("status", value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[macro_export]
    macro_rules ! _select_game { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: game :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: game :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: game :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: game :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: game :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: game :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , rated , game_key , game_name , clock_initial , clock_increment , first_name , first_provisional , first_rating , second_name , second_provisional , second_rating , rating_min , rating_max , start_pos , moves , first_time , second_time , status } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: game :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: game :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: game :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: game :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "createdAt" , "rated" , "gameKey" , "gameName" , "clockInitial" , "clockIncrement" , "firstName" , "firstProvisional" , "firstRating" , "secondName" , "secondProvisional" , "secondRating" , "ratingMin" , "ratingMax" , "startPos" , "moves" , "firstTime" , "secondTime" , "status"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: game :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { crate :: prisma :: game :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Game" , available relations are "id, created_at, rated, game_key, game_name, clock_initial, clock_increment, first_name, first_provisional, first_rating, second_name, second_provisional, second_rating, rating_min, rating_max, start_pos, moves, first_time, second_time, status")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: created_at :: Select) } ; (@ selection_field_to_selection_param ; rated) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: rated :: Select) } ; (@ selection_field_to_selection_param ; game_key) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: game_key :: Select) } ; (@ selection_field_to_selection_param ; game_name) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: game_name :: Select) } ; (@ selection_field_to_selection_param ; clock_initial) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: clock_initial :: Select) } ; (@ selection_field_to_selection_param ; clock_increment) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: clock_increment :: Select) } ; (@ selection_field_to_selection_param ; first_name) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: first_name :: Select) } ; (@ selection_field_to_selection_param ; first_provisional) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: first_provisional :: Select) } ; (@ selection_field_to_selection_param ; first_rating) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: first_rating :: Select) } ; (@ selection_field_to_selection_param ; second_name) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: second_name :: Select) } ; (@ selection_field_to_selection_param ; second_provisional) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: second_provisional :: Select) } ; (@ selection_field_to_selection_param ; second_rating) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: second_rating :: Select) } ; (@ selection_field_to_selection_param ; rating_min) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: rating_min :: Select) } ; (@ selection_field_to_selection_param ; rating_max) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: rating_max :: Select) } ; (@ selection_field_to_selection_param ; start_pos) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: start_pos :: Select) } ; (@ selection_field_to_selection_param ; moves) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: moves :: Select) } ; (@ selection_field_to_selection_param ; first_time) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: first_time :: Select) } ; (@ selection_field_to_selection_param ; second_time) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: second_time :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < crate :: prisma :: game :: SelectParam > :: into (crate :: prisma :: game :: status :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: game :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; (@ field_serde_name ; rated) => { "rated" } ; (@ field_serde_name ; game_key) => { "gameKey" } ; (@ field_serde_name ; game_name) => { "gameName" } ; (@ field_serde_name ; clock_initial) => { "clockInitial" } ; (@ field_serde_name ; clock_increment) => { "clockIncrement" } ; (@ field_serde_name ; first_name) => { "firstName" } ; (@ field_serde_name ; first_provisional) => { "firstProvisional" } ; (@ field_serde_name ; first_rating) => { "firstRating" } ; (@ field_serde_name ; second_name) => { "secondName" } ; (@ field_serde_name ; second_provisional) => { "secondProvisional" } ; (@ field_serde_name ; second_rating) => { "secondRating" } ; (@ field_serde_name ; rating_min) => { "ratingMin" } ; (@ field_serde_name ; rating_max) => { "ratingMax" } ; (@ field_serde_name ; start_pos) => { "startPos" } ; (@ field_serde_name ; moves) => { "moves" } ; (@ field_serde_name ; first_time) => { "firstTime" } ; (@ field_serde_name ; second_time) => { "secondTime" } ; (@ field_serde_name ; status) => { "status" } ; }
    pub use _select_game as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Rated(rated::Select),
        GameKey(game_key::Select),
        GameName(game_name::Select),
        ClockInitial(clock_initial::Select),
        ClockIncrement(clock_increment::Select),
        FirstName(first_name::Select),
        FirstProvisional(first_provisional::Select),
        FirstRating(first_rating::Select),
        SecondName(second_name::Select),
        SecondProvisional(second_provisional::Select),
        SecondRating(second_rating::Select),
        RatingMin(rating_min::Select),
        RatingMax(rating_max::Select),
        StartPos(start_pos::Select),
        Moves(moves::Select),
        FirstTime(first_time::Select),
        SecondTime(second_time::Select),
        Status(status::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Rated(data) => data.to_selection(),
                Self::GameKey(data) => data.to_selection(),
                Self::GameName(data) => data.to_selection(),
                Self::ClockInitial(data) => data.to_selection(),
                Self::ClockIncrement(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::FirstProvisional(data) => data.to_selection(),
                Self::FirstRating(data) => data.to_selection(),
                Self::SecondName(data) => data.to_selection(),
                Self::SecondProvisional(data) => data.to_selection(),
                Self::SecondRating(data) => data.to_selection(),
                Self::RatingMin(data) => data.to_selection(),
                Self::RatingMax(data) => data.to_selection(),
                Self::StartPos(data) => data.to_selection(),
                Self::Moves(data) => data.to_selection(),
                Self::FirstTime(data) => data.to_selection(),
                Self::SecondTime(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_game { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: game :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: game :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: game :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: game :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: game :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: game :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: game :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: game :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub rated : bool , pub game_key : String , pub game_name : String , pub clock_initial : Option < i32 > , pub clock_increment : Option < i32 > , pub first_name : Option < String > , pub first_provisional : Option < bool > , pub first_rating : Option < i32 > , pub second_name : Option < String > , pub second_provisional : Option < bool > , pub second_rating : Option < i32 > , pub rating_min : i32 , pub rating_max : i32 , pub start_pos : Option < String > , pub moves : String , pub first_time : Option < i32 > , pub second_time : Option < i32 > , pub status : crate :: prisma GameStatus , $ (pub $ field : crate :: prisma :: game :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (rated) , stringify ! (game_key) , stringify ! (game_name) , stringify ! (clock_initial) , stringify ! (clock_increment) , stringify ! (first_name) , stringify ! (first_provisional) , stringify ! (first_rating) , stringify ! (second_name) , stringify ! (second_provisional) , stringify ! (second_rating) , stringify ! (rating_min) , stringify ! (rating_max) , stringify ! (start_pos) , stringify ! (moves) , stringify ! (first_time) , stringify ! (second_time) , stringify ! (status)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: game :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: game :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: game :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: game :: rated :: NAME , & self . rated) ? ; state . serialize_field (crate :: prisma :: game :: game_key :: NAME , & self . game_key) ? ; state . serialize_field (crate :: prisma :: game :: game_name :: NAME , & self . game_name) ? ; state . serialize_field (crate :: prisma :: game :: clock_initial :: NAME , & self . clock_initial) ? ; state . serialize_field (crate :: prisma :: game :: clock_increment :: NAME , & self . clock_increment) ? ; state . serialize_field (crate :: prisma :: game :: first_name :: NAME , & self . first_name) ? ; state . serialize_field (crate :: prisma :: game :: first_provisional :: NAME , & self . first_provisional) ? ; state . serialize_field (crate :: prisma :: game :: first_rating :: NAME , & self . first_rating) ? ; state . serialize_field (crate :: prisma :: game :: second_name :: NAME , & self . second_name) ? ; state . serialize_field (crate :: prisma :: game :: second_provisional :: NAME , & self . second_provisional) ? ; state . serialize_field (crate :: prisma :: game :: second_rating :: NAME , & self . second_rating) ? ; state . serialize_field (crate :: prisma :: game :: rating_min :: NAME , & self . rating_min) ? ; state . serialize_field (crate :: prisma :: game :: rating_max :: NAME , & self . rating_max) ? ; state . serialize_field (crate :: prisma :: game :: start_pos :: NAME , & self . start_pos) ? ; state . serialize_field (crate :: prisma :: game :: moves :: NAME , & self . moves) ? ; state . serialize_field (crate :: prisma :: game :: first_time :: NAME , & self . first_time) ? ; state . serialize_field (crate :: prisma :: game :: second_time :: NAME , & self . second_time) ? ; state . serialize_field (crate :: prisma :: game :: status :: NAME , & self . status) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , rated , game_key , game_name , clock_initial , clock_increment , first_name , first_provisional , first_rating , second_name , second_provisional , second_rating , rating_min , rating_max , start_pos , moves , first_time , second_time , status } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: game :: $ field :: NAME) , + , crate :: prisma :: game :: id :: NAME , crate :: prisma :: game :: created_at :: NAME , crate :: prisma :: game :: rated :: NAME , crate :: prisma :: game :: game_key :: NAME , crate :: prisma :: game :: game_name :: NAME , crate :: prisma :: game :: clock_initial :: NAME , crate :: prisma :: game :: clock_increment :: NAME , crate :: prisma :: game :: first_name :: NAME , crate :: prisma :: game :: first_provisional :: NAME , crate :: prisma :: game :: first_rating :: NAME , crate :: prisma :: game :: second_name :: NAME , crate :: prisma :: game :: second_provisional :: NAME , crate :: prisma :: game :: second_rating :: NAME , crate :: prisma :: game :: rating_min :: NAME , crate :: prisma :: game :: rating_max :: NAME , crate :: prisma :: game :: start_pos :: NAME , crate :: prisma :: game :: moves :: NAME , crate :: prisma :: game :: first_time :: NAME , crate :: prisma :: game :: second_time :: NAME , crate :: prisma :: game :: status :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: game :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: game :: id :: NAME => Ok (Field :: id) , crate :: prisma :: game :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: game :: rated :: NAME => Ok (Field :: rated) , crate :: prisma :: game :: game_key :: NAME => Ok (Field :: game_key) , crate :: prisma :: game :: game_name :: NAME => Ok (Field :: game_name) , crate :: prisma :: game :: clock_initial :: NAME => Ok (Field :: clock_initial) , crate :: prisma :: game :: clock_increment :: NAME => Ok (Field :: clock_increment) , crate :: prisma :: game :: first_name :: NAME => Ok (Field :: first_name) , crate :: prisma :: game :: first_provisional :: NAME => Ok (Field :: first_provisional) , crate :: prisma :: game :: first_rating :: NAME => Ok (Field :: first_rating) , crate :: prisma :: game :: second_name :: NAME => Ok (Field :: second_name) , crate :: prisma :: game :: second_provisional :: NAME => Ok (Field :: second_provisional) , crate :: prisma :: game :: second_rating :: NAME => Ok (Field :: second_rating) , crate :: prisma :: game :: rating_min :: NAME => Ok (Field :: rating_min) , crate :: prisma :: game :: rating_max :: NAME => Ok (Field :: rating_max) , crate :: prisma :: game :: start_pos :: NAME => Ok (Field :: start_pos) , crate :: prisma :: game :: moves :: NAME => Ok (Field :: moves) , crate :: prisma :: game :: first_time :: NAME => Ok (Field :: first_time) , crate :: prisma :: game :: second_time :: NAME => Ok (Field :: second_time) , crate :: prisma :: game :: status :: NAME => Ok (Field :: status) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut rated = None ; let mut game_key = None ; let mut game_name = None ; let mut clock_initial = None ; let mut clock_increment = None ; let mut first_name = None ; let mut first_provisional = None ; let mut first_rating = None ; let mut second_name = None ; let mut second_provisional = None ; let mut second_rating = None ; let mut rating_min = None ; let mut rating_max = None ; let mut start_pos = None ; let mut moves = None ; let mut first_time = None ; let mut second_time = None ; let mut status = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: rated => { if rated . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: rated :: NAME)) ; } rated = Some (map . next_value () ?) ; } Field :: game_key => { if game_key . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: game_key :: NAME)) ; } game_key = Some (map . next_value () ?) ; } Field :: game_name => { if game_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: game_name :: NAME)) ; } game_name = Some (map . next_value () ?) ; } Field :: clock_initial => { if clock_initial . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: clock_initial :: NAME)) ; } clock_initial = Some (map . next_value () ?) ; } Field :: clock_increment => { if clock_increment . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: clock_increment :: NAME)) ; } clock_increment = Some (map . next_value () ?) ; } Field :: first_name => { if first_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: first_name :: NAME)) ; } first_name = Some (map . next_value () ?) ; } Field :: first_provisional => { if first_provisional . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: first_provisional :: NAME)) ; } first_provisional = Some (map . next_value () ?) ; } Field :: first_rating => { if first_rating . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: first_rating :: NAME)) ; } first_rating = Some (map . next_value () ?) ; } Field :: second_name => { if second_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: second_name :: NAME)) ; } second_name = Some (map . next_value () ?) ; } Field :: second_provisional => { if second_provisional . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: second_provisional :: NAME)) ; } second_provisional = Some (map . next_value () ?) ; } Field :: second_rating => { if second_rating . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: second_rating :: NAME)) ; } second_rating = Some (map . next_value () ?) ; } Field :: rating_min => { if rating_min . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: rating_min :: NAME)) ; } rating_min = Some (map . next_value () ?) ; } Field :: rating_max => { if rating_max . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: rating_max :: NAME)) ; } rating_max = Some (map . next_value () ?) ; } Field :: start_pos => { if start_pos . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: start_pos :: NAME)) ; } start_pos = Some (map . next_value () ?) ; } Field :: moves => { if moves . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: moves :: NAME)) ; } moves = Some (map . next_value () ?) ; } Field :: first_time => { if first_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: first_time :: NAME)) ; } first_time = Some (map . next_value () ?) ; } Field :: second_time => { if second_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: second_time :: NAME)) ; } second_time = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: status :: NAME)) ; } status = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: game :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: created_at :: NAME)) ? ; let rated = rated . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: rated :: NAME)) ? ; let game_key = game_key . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: game_key :: NAME)) ? ; let game_name = game_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: game_name :: NAME)) ? ; let clock_initial = clock_initial . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: clock_initial :: NAME)) ? ; let clock_increment = clock_increment . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: clock_increment :: NAME)) ? ; let first_name = first_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: first_name :: NAME)) ? ; let first_provisional = first_provisional . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: first_provisional :: NAME)) ? ; let first_rating = first_rating . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: first_rating :: NAME)) ? ; let second_name = second_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: second_name :: NAME)) ? ; let second_provisional = second_provisional . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: second_provisional :: NAME)) ? ; let second_rating = second_rating . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: second_rating :: NAME)) ? ; let rating_min = rating_min . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: rating_min :: NAME)) ? ; let rating_max = rating_max . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: rating_max :: NAME)) ? ; let start_pos = start_pos . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: start_pos :: NAME)) ? ; let moves = moves . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: moves :: NAME)) ? ; let first_time = first_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: first_time :: NAME)) ? ; let second_time = second_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: second_time :: NAME)) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: game :: status :: NAME)) ? ; Ok (Data { id , created_at , rated , game_key , game_name , clock_initial , clock_increment , first_name , first_provisional , first_rating , second_name , second_provisional , second_rating , rating_min , rating_max , start_pos , moves , first_time , second_time , status , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "createdAt" , "rated" , "gameKey" , "gameName" , "clockInitial" , "clockIncrement" , "firstName" , "firstProvisional" , "firstRating" , "secondName" , "secondProvisional" , "secondRating" , "ratingMin" , "ratingMax" , "startPos" , "moves" , "firstTime" , "secondTime" , "status"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: game :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { crate :: prisma :: game :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Game" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: game :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; (@ field_serde_name ; rated) => { "rated" } ; (@ field_serde_name ; game_key) => { "gameKey" } ; (@ field_serde_name ; game_name) => { "gameName" } ; (@ field_serde_name ; clock_initial) => { "clockInitial" } ; (@ field_serde_name ; clock_increment) => { "clockIncrement" } ; (@ field_serde_name ; first_name) => { "firstName" } ; (@ field_serde_name ; first_provisional) => { "firstProvisional" } ; (@ field_serde_name ; first_rating) => { "firstRating" } ; (@ field_serde_name ; second_name) => { "secondName" } ; (@ field_serde_name ; second_provisional) => { "secondProvisional" } ; (@ field_serde_name ; second_rating) => { "secondRating" } ; (@ field_serde_name ; rating_min) => { "ratingMin" } ; (@ field_serde_name ; rating_max) => { "ratingMax" } ; (@ field_serde_name ; start_pos) => { "startPos" } ; (@ field_serde_name ; moves) => { "moves" } ; (@ field_serde_name ; first_time) => { "firstTime" } ; (@ field_serde_name ; second_time) => { "secondTime" } ; (@ field_serde_name ; status) => { "status" } ; }
    pub use _include_game as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Rated(rated::Include),
        GameKey(game_key::Include),
        GameName(game_name::Include),
        ClockInitial(clock_initial::Include),
        ClockIncrement(clock_increment::Include),
        FirstName(first_name::Include),
        FirstProvisional(first_provisional::Include),
        FirstRating(first_rating::Include),
        SecondName(second_name::Include),
        SecondProvisional(second_provisional::Include),
        SecondRating(second_rating::Include),
        RatingMin(rating_min::Include),
        RatingMax(rating_max::Include),
        StartPos(start_pos::Include),
        Moves(moves::Include),
        FirstTime(first_time::Include),
        SecondTime(second_time::Include),
        Status(status::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Rated(data) => data.to_selection(),
                Self::GameKey(data) => data.to_selection(),
                Self::GameName(data) => data.to_selection(),
                Self::ClockInitial(data) => data.to_selection(),
                Self::ClockIncrement(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::FirstProvisional(data) => data.to_selection(),
                Self::FirstRating(data) => data.to_selection(),
                Self::SecondName(data) => data.to_selection(),
                Self::SecondProvisional(data) => data.to_selection(),
                Self::SecondRating(data) => data.to_selection(),
                Self::RatingMin(data) => data.to_selection(),
                Self::RatingMax(data) => data.to_selection(),
                Self::StartPos(data) => data.to_selection(),
                Self::Moves(data) => data.to_selection(),
                Self::FirstTime(data) => data.to_selection(),
                Self::SecondTime(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
            }
        }
    }
    pub mod clock_increment {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "clockIncrement";
        pub type Type = Option<i32>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ClockIncrement(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            ClockIncrement,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ClockIncrement(v)
            }
        }
        pub struct Set(pub Option<i32>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ClockIncrement(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ClockIncrement(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ClockIncrement(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ClockIncrement(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ClockIncrement(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ClockIncrement(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod clock_initial {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "clockInitial";
        pub type Type = Option<i32>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ClockInitial(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            ClockInitial,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::ClockInitial(v)
            }
        }
        pub struct Set(pub Option<i32>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ClockInitial(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::ClockInitial(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ClockInitial(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::ClockInitial(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ClockInitial(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ClockInitial(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "createdAt";
        pub type Type =
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
        pub type RecursiveSafeType = Type;
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CreatedAt(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(_prisma::write_params::DateTimeParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod first_name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "firstName";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            FirstName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FirstName(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstName(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstName(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstName(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstName(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod first_provisional {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "firstProvisional";
        pub type Type = Option<bool>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<bool>) -> WhereParam {
            WhereParam::FirstProvisional(_prisma::read_filters::BooleanNullableFilter::Equals(
                value,
            ))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanNullableFilter,
            FirstProvisional,
            {
                fn not(_: Option<bool>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FirstProvisional(v)
            }
        }
        pub struct Set(pub Option<bool>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstProvisional(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstProvisional(_prisma::write_params::BooleanNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<bool>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstProvisional(_prisma::write_params::BooleanNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstProvisional(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstProvisional(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstProvisional(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod first_rating {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "firstRating";
        pub type Type = Option<i32>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::FirstRating(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            FirstRating,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FirstRating(v)
            }
        }
        pub struct Set(pub Option<i32>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstRating(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstRating(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstRating(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstRating(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstRating(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstRating(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod first_time {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "firstTime";
        pub type Type = Option<i32>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::FirstTime(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            FirstTime,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::FirstTime(v)
            }
        }
        pub struct Set(pub Option<i32>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstTime(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstTime(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstTime(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::FirstTime(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod game_key {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "gameKey";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GameKey(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            GameKey,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::GameKey(v)
            }
        }
        pub struct Set(pub String);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::GameKey(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::GameKey(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::GameKey(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::GameKey(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GameKey(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GameKey(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod game_name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "gameName";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: String) -> WhereParam {
            WhereParam::GameName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            GameName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::GameName(v)
            }
        }
        pub struct Set(pub String);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::GameName(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::GameName(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::GameName(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::GameName(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::GameName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::GameName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod id {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "id";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Id(v)
            }
        }
        pub struct Set(pub String);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Id(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod moves {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "moves";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Moves(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Moves,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Moves(v)
            }
        }
        pub struct Set(pub String);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Moves(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Moves(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Moves(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Moves(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Moves(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Moves(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod rated {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "rated";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::Rated(_prisma::read_filters::BooleanFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            Rated,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Rated(v)
            }
        }
        pub struct Set(pub bool);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Rated(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Rated(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Rated(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Rated(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Rated(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Rated(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod rating_max {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "ratingMax";
        pub type Type = i32;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::RatingMax(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            RatingMax,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::RatingMax(v)
            }
        }
        pub struct Set(pub i32);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::RatingMax(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::RatingMax(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RatingMax(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::RatingMax(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RatingMax(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RatingMax(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod rating_min {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "ratingMin";
        pub type Type = i32;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::RatingMin(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            RatingMin,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::RatingMin(v)
            }
        }
        pub struct Set(pub i32);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::RatingMin(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::RatingMin(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RatingMin(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::RatingMin(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RatingMin(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RatingMin(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod second_name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "secondName";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::SecondName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            SecondName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::SecondName(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondName(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondName(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondName(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondName(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SecondName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SecondName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod second_provisional {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "secondProvisional";
        pub type Type = Option<bool>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<bool>) -> WhereParam {
            WhereParam::SecondProvisional(_prisma::read_filters::BooleanNullableFilter::Equals(
                value,
            ))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanNullableFilter,
            SecondProvisional,
            {
                fn not(_: Option<bool>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::SecondProvisional(v)
            }
        }
        pub struct Set(pub Option<bool>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondProvisional(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondProvisional(_prisma::write_params::BooleanNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<bool>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondProvisional(_prisma::write_params::BooleanNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondProvisional(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SecondProvisional(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SecondProvisional(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod second_rating {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "secondRating";
        pub type Type = Option<i32>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::SecondRating(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            SecondRating,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::SecondRating(v)
            }
        }
        pub struct Set(pub Option<i32>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondRating(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondRating(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondRating(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondRating(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SecondRating(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SecondRating(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod second_time {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "secondTime";
        pub type Type = Option<i32>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::SecondTime(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            SecondTime,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::SecondTime(v)
            }
        }
        pub struct Set(pub Option<i32>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondTime(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondTime(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SecondTime(_prisma::write_params::IntNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::SecondTime(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SecondTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SecondTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod start_pos {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "startPos";
        pub type Type = Option<String>;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::StartPos(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            StartPos,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::StartPos(v)
            }
        }
        pub struct Set(pub Option<String>);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::StartPos(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::StartPos(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::StartPos(_prisma::write_params::StringNullableParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::StartPos(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StartPos(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StartPos(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod status {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "status";
        pub type Type = crate::prisma::GameStatus;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: GameStatus) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::GameStatusFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::GameStatusFilter,
            Status,
            {
                fn in_vec(_: Vec<GameStatus>) -> InVec;
                fn not_in_vec(_: Vec<GameStatus>) -> NotInVec;
                fn not(_: GameStatus) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Status(v)
            }
        }
        pub struct Set(pub GameStatus);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Status(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Status(_prisma::write_params::GameStatusParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: GameStatus) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::GameStatusParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Status(_prisma::write_params::GameStatusParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Status(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Status(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Status(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub rated: bool,
        pub game_key: String,
        pub game_name: String,
        pub rating_min: i32,
        pub rating_max: i32,
        pub moves: String,
        pub status: super::GameStatus,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.game().create(
                self.rated,
                self.game_key,
                self.game_name,
                self.rating_min,
                self.rating_max,
                self.moves,
                self.status,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                rated::set(self.rated),
                game_key::set(self.game_key),
                game_name::set(self.game_name),
                rating_min::set(self.rating_min),
                rating_max::set(self.rating_max),
                moves::set(self.moves),
                status::set(self.status),
            ]);
            self._params
        }
    }
    pub fn create(
        rated: bool,
        game_key: String,
        game_name: String,
        rating_min: i32,
        rating_max: i32,
        moves: String,
        status: super::GameStatus,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            rated,
            game_key,
            game_name,
            rating_min,
            rating_max,
            moves,
            status,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub rated: bool,
        pub game_key: String,
        pub game_name: String,
        pub rating_min: i32,
        pub rating_max: i32,
        pub moves: String,
        pub status: super::GameStatus,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.game().create_unchecked(
                self.rated,
                self.game_key,
                self.game_name,
                self.rating_min,
                self.rating_max,
                self.moves,
                self.status,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                rated::set(self.rated),
                game_key::set(self.game_key),
                game_name::set(self.game_name),
                rating_min::set(self.rating_min),
                rating_max::set(self.rating_max),
                moves::set(self.moves),
                status::set(self.status),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        rated: bool,
        game_key: String,
        game_name: String,
        rating_min: i32,
        rating_max: i32,
        moves: String,
        status: super::GameStatus,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            rated,
            game_key,
            game_name,
            rating_min,
            rating_max,
            moves,
            status,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(rated::NAME),
                ::prisma_client_rust::sel(game_key::NAME),
                ::prisma_client_rust::sel(game_name::NAME),
                ::prisma_client_rust::sel(clock_initial::NAME),
                ::prisma_client_rust::sel(clock_increment::NAME),
                ::prisma_client_rust::sel(first_name::NAME),
                ::prisma_client_rust::sel(first_provisional::NAME),
                ::prisma_client_rust::sel(first_rating::NAME),
                ::prisma_client_rust::sel(second_name::NAME),
                ::prisma_client_rust::sel(second_provisional::NAME),
                ::prisma_client_rust::sel(second_rating::NAME),
                ::prisma_client_rust::sel(rating_min::NAME),
                ::prisma_client_rust::sel(rating_max::NAME),
                ::prisma_client_rust::sel(start_pos::NAME),
                ::prisma_client_rust::sel(moves::NAME),
                ::prisma_client_rust::sel(first_time::NAME),
                ::prisma_client_rust::sel(second_time::NAME),
                ::prisma_client_rust::sel(status::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: id::Type,
        #[serde(rename = "createdAt")]
        pub created_at: created_at::Type,
        #[serde(rename = "rated")]
        pub rated: rated::Type,
        #[serde(rename = "gameKey")]
        pub game_key: game_key::Type,
        #[serde(rename = "gameName")]
        pub game_name: game_name::Type,
        #[serde(rename = "clockInitial")]
        pub clock_initial: clock_initial::Type,
        #[serde(rename = "clockIncrement")]
        pub clock_increment: clock_increment::Type,
        #[serde(rename = "firstName")]
        pub first_name: first_name::Type,
        #[serde(rename = "firstProvisional")]
        pub first_provisional: first_provisional::Type,
        #[serde(rename = "firstRating")]
        pub first_rating: first_rating::Type,
        #[serde(rename = "secondName")]
        pub second_name: second_name::Type,
        #[serde(rename = "secondProvisional")]
        pub second_provisional: second_provisional::Type,
        #[serde(rename = "secondRating")]
        pub second_rating: second_rating::Type,
        #[serde(rename = "ratingMin")]
        pub rating_min: rating_min::Type,
        #[serde(rename = "ratingMax")]
        pub rating_max: rating_max::Type,
        #[serde(rename = "startPos")]
        pub start_pos: start_pos::Type,
        #[serde(rename = "moves")]
        pub moves: moves::Type,
        #[serde(rename = "firstTime")]
        pub first_time: first_time::Type,
        #[serde(rename = "secondTime")]
        pub second_time: second_time::Type,
        #[serde(rename = "status")]
        pub status: status::Type,
    }
    impl Data {}
    #[macro_export]
    macro_rules ! _partial_unchecked_game { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: game struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "createdAt")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "rated")] pub rated : bool , # [serde (rename = "gameKey")] pub game_key : String , # [serde (rename = "gameName")] pub game_name : String , # [serde (rename = "clockInitial")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub clock_initial : Option < i32 > , # [serde (rename = "clockIncrement")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub clock_increment : Option < i32 > , # [serde (rename = "firstName")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub first_name : Option < String > , # [serde (rename = "firstProvisional")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub first_provisional : Option < bool > , # [serde (rename = "firstRating")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub first_rating : Option < i32 > , # [serde (rename = "secondName")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub second_name : Option < String > , # [serde (rename = "secondProvisional")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub second_provisional : Option < bool > , # [serde (rename = "secondRating")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub second_rating : Option < i32 > , # [serde (rename = "ratingMin")] pub rating_min : i32 , # [serde (rename = "ratingMax")] pub rating_max : i32 , # [serde (rename = "startPos")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub start_pos : Option < String > , # [serde (rename = "moves")] pub moves : String , # [serde (rename = "firstTime")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub first_time : Option < i32 > , # [serde (rename = "secondTime")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub second_time : Option < i32 > , # [serde (rename = "status")] pub status : crate :: prisma GameStatus } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_game as partial_unchecked;
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            rated: bool,
            game_key: String,
            game_name: String,
            rating_min: i32,
            rating_max: i32,
            moves: String,
            status: super::GameStatus,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            _params.extend([
                rated::set(rated),
                game_key::set(game_key),
                game_name::set(game_name),
                rating_min::set(rating_min),
                rating_max::set(rating_max),
                moves::set(moves),
                status::set(status),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            rated: bool,
            game_key: String,
            game_name: String,
            rating_min: i32,
            rating_max: i32,
            moves: String,
            status: super::GameStatus,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            _params.extend([
                rated::set(rated),
                game_key::set(game_key),
                game_name::set(game_name),
                rating_min::set(rating_min),
                rating_max::set(rating_max),
                moves::set(moves),
                status::set(status),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
}
pub mod user {
    use super::_prisma::*;
    pub const NAME: &str = "User";
    #[derive(Debug, Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Name(super::_prisma::read_filters::StringFilter),
        TttRating(super::_prisma::read_filters::IntFilter),
        TttProvisional(super::_prisma::read_filters::BooleanFilter),
        UtttRating(super::_prisma::read_filters::IntFilter),
        UtttProvisional(super::_prisma::read_filters::BooleanFilter),
        C4Rating(super::_prisma::read_filters::IntFilter),
        C4Provisional(super::_prisma::read_filters::BooleanFilter),
        PcRating(super::_prisma::read_filters::IntFilter),
        PcProvisional(super::_prisma::read_filters::BooleanFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Name(value) => (name::NAME, value.into()),
                Self::TttRating(value) => (ttt_rating::NAME, value.into()),
                Self::TttProvisional(value) => (ttt_provisional::NAME, value.into()),
                Self::UtttRating(value) => (uttt_rating::NAME, value.into()),
                Self::UtttProvisional(value) => (uttt_provisional::NAME, value.into()),
                Self::C4Rating(value) => (c_4_rating::NAME, value.into()),
                Self::C4Provisional(value) => (c_4_provisional::NAME, value.into()),
                Self::PcRating(value) => (pc_rating::NAME, value.into()),
                Self::PcProvisional(value) => (pc_provisional::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
        }
    }
    #[derive(Debug, Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => {
                    Self::Name(super::_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Debug, Clone)]
    pub enum OrderByWithRelationParam {
        Name(super::SortOrder),
        TttRating(super::SortOrder),
        TttProvisional(super::SortOrder),
        UtttRating(super::SortOrder),
        UtttProvisional(super::SortOrder),
        C4Rating(super::SortOrder),
        C4Provisional(super::SortOrder),
        PcRating(super::SortOrder),
        PcProvisional(super::SortOrder),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Name(param) => ("name", param.into()),
                Self::TttRating(param) => ("tttRating", param.into()),
                Self::TttProvisional(param) => ("tttProvisional", param.into()),
                Self::UtttRating(param) => ("utttRating", param.into()),
                Self::UtttProvisional(param) => ("utttProvisional", param.into()),
                Self::C4Rating(param) => ("c4Rating", param.into()),
                Self::C4Provisional(param) => ("c4Provisional", param.into()),
                Self::PcRating(param) => ("pcRating", param.into()),
                Self::PcProvisional(param) => ("pcProvisional", param.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Debug, Clone)]
    pub enum SetParam {
        Name(super::_prisma::write_params::StringParam),
        TttRating(super::_prisma::write_params::IntParam),
        TttProvisional(super::_prisma::write_params::BooleanParam),
        UtttRating(super::_prisma::write_params::IntParam),
        UtttProvisional(super::_prisma::write_params::BooleanParam),
        C4Rating(super::_prisma::write_params::IntParam),
        C4Provisional(super::_prisma::write_params::BooleanParam),
        PcRating(super::_prisma::write_params::IntParam),
        PcProvisional(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Name(value) => (name::NAME, value.into()),
                Self::TttRating(value) => (ttt_rating::NAME, value.into()),
                Self::TttProvisional(value) => (ttt_provisional::NAME, value.into()),
                Self::UtttRating(value) => (uttt_rating::NAME, value.into()),
                Self::UtttProvisional(value) => (uttt_provisional::NAME, value.into()),
                Self::C4Rating(value) => (c_4_rating::NAME, value.into()),
                Self::C4Provisional(value) => (c_4_provisional::NAME, value.into()),
                Self::PcRating(value) => (pc_rating::NAME, value.into()),
                Self::PcProvisional(value) => (pc_provisional::NAME, value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[derive(Debug, Clone)]
    pub enum UncheckedSetParam {
        Name(super::_prisma::write_params::StringParam),
        TttRating(super::_prisma::write_params::IntParam),
        TttProvisional(super::_prisma::write_params::BooleanParam),
        UtttRating(super::_prisma::write_params::IntParam),
        UtttProvisional(super::_prisma::write_params::BooleanParam),
        C4Rating(super::_prisma::write_params::IntParam),
        C4Provisional(super::_prisma::write_params::BooleanParam),
        PcRating(super::_prisma::write_params::IntParam),
        PcProvisional(super::_prisma::write_params::BooleanParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            let (k, v) = match self {
                Self::Name(value) => ("name", value.into()),
                Self::TttRating(value) => ("tttRating", value.into()),
                Self::TttProvisional(value) => ("tttProvisional", value.into()),
                Self::UtttRating(value) => ("utttRating", value.into()),
                Self::UtttProvisional(value) => ("utttProvisional", value.into()),
                Self::C4Rating(value) => ("c4Rating", value.into()),
                Self::C4Provisional(value) => ("c4Provisional", value.into()),
                Self::PcRating(value) => ("pcRating", value.into()),
                Self::PcProvisional(value) => ("pcProvisional", value.into()),
            };
            (k.to_string(), v)
        }
    }
    #[macro_export]
    macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { name , ttt_rating , ttt_provisional , uttt_rating , uttt_provisional , c_4_rating , c_4_provisional , pc_rating , pc_provisional } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["name" , "tttRating" , "tttProvisional" , "utttRating" , "utttProvisional" , "c4Rating" , "c4Provisional" , "pcRating" , "pcProvisional"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { crate :: prisma :: user :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "name, ttt_rating, ttt_provisional, uttt_rating, uttt_provisional, c_4_rating, c_4_provisional, pc_rating, pc_provisional")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: name :: Select) } ; (@ selection_field_to_selection_param ; ttt_rating) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: ttt_rating :: Select) } ; (@ selection_field_to_selection_param ; ttt_provisional) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: ttt_provisional :: Select) } ; (@ selection_field_to_selection_param ; uttt_rating) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: uttt_rating :: Select) } ; (@ selection_field_to_selection_param ; uttt_provisional) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: uttt_provisional :: Select) } ; (@ selection_field_to_selection_param ; c_4_rating) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: c_4_rating :: Select) } ; (@ selection_field_to_selection_param ; c_4_provisional) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: c_4_provisional :: Select) } ; (@ selection_field_to_selection_param ; pc_rating) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: pc_rating :: Select) } ; (@ selection_field_to_selection_param ; pc_provisional) => { Into :: < crate :: prisma :: user :: SelectParam > :: into (crate :: prisma :: user :: pc_provisional :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; ttt_rating) => { "tttRating" } ; (@ field_serde_name ; ttt_provisional) => { "tttProvisional" } ; (@ field_serde_name ; uttt_rating) => { "utttRating" } ; (@ field_serde_name ; uttt_provisional) => { "utttProvisional" } ; (@ field_serde_name ; c_4_rating) => { "c4Rating" } ; (@ field_serde_name ; c_4_provisional) => { "c4Provisional" } ; (@ field_serde_name ; pc_rating) => { "pcRating" } ; (@ field_serde_name ; pc_provisional) => { "pcProvisional" } ; }
    pub use _select_user as select;
    pub enum SelectParam {
        Name(name::Select),
        TttRating(ttt_rating::Select),
        TttProvisional(ttt_provisional::Select),
        UtttRating(uttt_rating::Select),
        UtttProvisional(uttt_provisional::Select),
        C4Rating(c_4_rating::Select),
        C4Provisional(c_4_provisional::Select),
        PcRating(pc_rating::Select),
        PcProvisional(pc_provisional::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Name(data) => data.to_selection(),
                Self::TttRating(data) => data.to_selection(),
                Self::TttProvisional(data) => data.to_selection(),
                Self::UtttRating(data) => data.to_selection(),
                Self::UtttProvisional(data) => data.to_selection(),
                Self::C4Rating(data) => data.to_selection(),
                Self::C4Provisional(data) => data.to_selection(),
                Self::PcRating(data) => data.to_selection(),
                Self::PcProvisional(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub name : String , pub ttt_rating : i32 , pub ttt_provisional : bool , pub uttt_rating : i32 , pub uttt_provisional : bool , pub c_4_rating : i32 , pub c_4_provisional : bool , pub pc_rating : i32 , pub pc_provisional : bool , $ (pub $ field : crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (name) , stringify ! (ttt_rating) , stringify ! (ttt_provisional) , stringify ! (uttt_rating) , stringify ! (uttt_provisional) , stringify ! (c_4_rating) , stringify ! (c_4_provisional) , stringify ! (pc_rating) , stringify ! (pc_provisional)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: user :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: user :: ttt_rating :: NAME , & self . ttt_rating) ? ; state . serialize_field (crate :: prisma :: user :: ttt_provisional :: NAME , & self . ttt_provisional) ? ; state . serialize_field (crate :: prisma :: user :: uttt_rating :: NAME , & self . uttt_rating) ? ; state . serialize_field (crate :: prisma :: user :: uttt_provisional :: NAME , & self . uttt_provisional) ? ; state . serialize_field (crate :: prisma :: user :: c_4_rating :: NAME , & self . c_4_rating) ? ; state . serialize_field (crate :: prisma :: user :: c_4_provisional :: NAME , & self . c_4_provisional) ? ; state . serialize_field (crate :: prisma :: user :: pc_rating :: NAME , & self . pc_rating) ? ; state . serialize_field (crate :: prisma :: user :: pc_provisional :: NAME , & self . pc_provisional) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , name , ttt_rating , ttt_provisional , uttt_rating , uttt_provisional , c_4_rating , c_4_provisional , pc_rating , pc_provisional } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user :: $ field :: NAME) , + , crate :: prisma :: user :: name :: NAME , crate :: prisma :: user :: ttt_rating :: NAME , crate :: prisma :: user :: ttt_provisional :: NAME , crate :: prisma :: user :: uttt_rating :: NAME , crate :: prisma :: user :: uttt_provisional :: NAME , crate :: prisma :: user :: c_4_rating :: NAME , crate :: prisma :: user :: c_4_provisional :: NAME , crate :: prisma :: user :: pc_rating :: NAME , crate :: prisma :: user :: pc_provisional :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: user :: name :: NAME => Ok (Field :: name) , crate :: prisma :: user :: ttt_rating :: NAME => Ok (Field :: ttt_rating) , crate :: prisma :: user :: ttt_provisional :: NAME => Ok (Field :: ttt_provisional) , crate :: prisma :: user :: uttt_rating :: NAME => Ok (Field :: uttt_rating) , crate :: prisma :: user :: uttt_provisional :: NAME => Ok (Field :: uttt_provisional) , crate :: prisma :: user :: c_4_rating :: NAME => Ok (Field :: c_4_rating) , crate :: prisma :: user :: c_4_provisional :: NAME => Ok (Field :: c_4_provisional) , crate :: prisma :: user :: pc_rating :: NAME => Ok (Field :: pc_rating) , crate :: prisma :: user :: pc_provisional :: NAME => Ok (Field :: pc_provisional) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut name = None ; let mut ttt_rating = None ; let mut ttt_provisional = None ; let mut uttt_rating = None ; let mut uttt_provisional = None ; let mut c_4_rating = None ; let mut c_4_provisional = None ; let mut pc_rating = None ; let mut pc_provisional = None ; while let Some (key) = map . next_key () ? { match key { Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: ttt_rating => { if ttt_rating . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: ttt_rating :: NAME)) ; } ttt_rating = Some (map . next_value () ?) ; } Field :: ttt_provisional => { if ttt_provisional . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: ttt_provisional :: NAME)) ; } ttt_provisional = Some (map . next_value () ?) ; } Field :: uttt_rating => { if uttt_rating . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: uttt_rating :: NAME)) ; } uttt_rating = Some (map . next_value () ?) ; } Field :: uttt_provisional => { if uttt_provisional . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: uttt_provisional :: NAME)) ; } uttt_provisional = Some (map . next_value () ?) ; } Field :: c_4_rating => { if c_4_rating . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: c_4_rating :: NAME)) ; } c_4_rating = Some (map . next_value () ?) ; } Field :: c_4_provisional => { if c_4_provisional . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: c_4_provisional :: NAME)) ; } c_4_provisional = Some (map . next_value () ?) ; } Field :: pc_rating => { if pc_rating . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: pc_rating :: NAME)) ; } pc_rating = Some (map . next_value () ?) ; } Field :: pc_provisional => { if pc_provisional . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: pc_provisional :: NAME)) ; } pc_provisional = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: $ field :: NAME)) ? ;) * let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: name :: NAME)) ? ; let ttt_rating = ttt_rating . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: ttt_rating :: NAME)) ? ; let ttt_provisional = ttt_provisional . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: ttt_provisional :: NAME)) ? ; let uttt_rating = uttt_rating . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: uttt_rating :: NAME)) ? ; let uttt_provisional = uttt_provisional . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: uttt_provisional :: NAME)) ? ; let c_4_rating = c_4_rating . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: c_4_rating :: NAME)) ? ; let c_4_provisional = c_4_provisional . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: c_4_provisional :: NAME)) ? ; let pc_rating = pc_rating . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: pc_rating :: NAME)) ? ; let pc_provisional = pc_provisional . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user :: pc_provisional :: NAME)) ? ; Ok (Data { name , ttt_rating , ttt_provisional , uttt_rating , uttt_provisional , c_4_rating , c_4_provisional , pc_rating , pc_provisional , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["name" , "tttRating" , "tttProvisional" , "utttRating" , "utttProvisional" , "c4Rating" , "c4Provisional" , "pcRating" , "pcProvisional"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { crate :: prisma :: user :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; ttt_rating) => { "tttRating" } ; (@ field_serde_name ; ttt_provisional) => { "tttProvisional" } ; (@ field_serde_name ; uttt_rating) => { "utttRating" } ; (@ field_serde_name ; uttt_provisional) => { "utttProvisional" } ; (@ field_serde_name ; c_4_rating) => { "c4Rating" } ; (@ field_serde_name ; c_4_provisional) => { "c4Provisional" } ; (@ field_serde_name ; pc_rating) => { "pcRating" } ; (@ field_serde_name ; pc_provisional) => { "pcProvisional" } ; }
    pub use _include_user as include;
    pub enum IncludeParam {
        Name(name::Include),
        TttRating(ttt_rating::Include),
        TttProvisional(ttt_provisional::Include),
        UtttRating(uttt_rating::Include),
        UtttProvisional(uttt_provisional::Include),
        C4Rating(c_4_rating::Include),
        C4Provisional(c_4_provisional::Include),
        PcRating(pc_rating::Include),
        PcProvisional(pc_provisional::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Name(data) => data.to_selection(),
                Self::TttRating(data) => data.to_selection(),
                Self::TttProvisional(data) => data.to_selection(),
                Self::UtttRating(data) => data.to_selection(),
                Self::UtttProvisional(data) => data.to_selection(),
                Self::C4Rating(data) => data.to_selection(),
                Self::C4Provisional(data) => data.to_selection(),
                Self::PcRating(data) => data.to_selection(),
                Self::PcProvisional(data) => data.to_selection(),
            }
        }
    }
    pub mod c_4_provisional {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "c4Provisional";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::C4Provisional(_prisma::read_filters::BooleanFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            C4Provisional,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::C4Provisional(v)
            }
        }
        pub struct Set(pub bool);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::C4Provisional(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::C4Provisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::C4Provisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::C4Provisional(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::C4Provisional(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::C4Provisional(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod c_4_rating {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "c4Rating";
        pub type Type = i32;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::C4Rating(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            C4Rating,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::C4Rating(v)
            }
        }
        pub struct Set(pub i32);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::C4Rating(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::C4Rating(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::C4Rating(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::C4Rating(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::C4Rating(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::C4Rating(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "name";
        pub type Type = String;
        pub type RecursiveSafeType = Type;
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::Name(v)
            }
        }
        pub struct Set(pub String);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::StringParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(_prisma::write_params::StringParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::Name(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod pc_provisional {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "pcProvisional";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::PcProvisional(_prisma::read_filters::BooleanFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            PcProvisional,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::PcProvisional(v)
            }
        }
        pub struct Set(pub bool);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PcProvisional(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::PcProvisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PcProvisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PcProvisional(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PcProvisional(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PcProvisional(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod pc_rating {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "pcRating";
        pub type Type = i32;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::PcRating(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            PcRating,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::PcRating(v)
            }
        }
        pub struct Set(pub i32);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PcRating(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::PcRating(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PcRating(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::PcRating(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PcRating(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PcRating(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod ttt_provisional {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "tttProvisional";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::TttProvisional(_prisma::read_filters::BooleanFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            TttProvisional,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::TttProvisional(v)
            }
        }
        pub struct Set(pub bool);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::TttProvisional(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::TttProvisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TttProvisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::TttProvisional(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TttProvisional(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TttProvisional(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod ttt_rating {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "tttRating";
        pub type Type = i32;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TttRating(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            TttRating,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::TttRating(v)
            }
        }
        pub struct Set(pub i32);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::TttRating(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::TttRating(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TttRating(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::TttRating(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TttRating(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TttRating(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod uttt_provisional {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "utttProvisional";
        pub type Type = bool;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::UtttProvisional(_prisma::read_filters::BooleanFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BooleanFilter,
            UtttProvisional,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::UtttProvisional(v)
            }
        }
        pub struct Set(pub bool);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UtttProvisional(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::UtttProvisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UtttProvisional(_prisma::write_params::BooleanParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UtttProvisional(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UtttProvisional(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UtttProvisional(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod uttt_rating {
        use super::super::{_prisma::*, *};
        use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
        pub const NAME: &str = "utttRating";
        pub type Type = i32;
        pub type RecursiveSafeType = Type;
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UtttRating(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            UtttRating,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub struct Order(SortOrder);
        pub fn order<T: From<Order>>(v: SortOrder) -> T {
            Order(v).into()
        }
        impl From<Order> for super::OrderByWithRelationParam {
            fn from(Order(v): Order) -> Self {
                Self::UtttRating(v)
            }
        }
        pub struct Set(pub i32);
        impl From<UpdateOperation> for SetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UtttRating(v)
            }
        }
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::UtttRating(_prisma::write_params::IntParam::Set(v))
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub struct UpdateOperation(pub _prisma::write_params::IntParam);
        pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
        }
        pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
        }
        pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
        }
        pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
            UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UtttRating(_prisma::write_params::IntParam::Set(v))
            }
        }
        impl From<UpdateOperation> for UncheckedSetParam {
            fn from(UpdateOperation(v): UpdateOperation) -> Self {
                Self::UtttRating(v)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UtttRating(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UtttRating(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    #[derive(Debug, Clone)]
    pub struct Create {
        pub name: String,
        pub ttt_rating: i32,
        pub ttt_provisional: bool,
        pub uttt_rating: i32,
        pub uttt_provisional: bool,
        pub c_4_rating: i32,
        pub c_4_provisional: bool,
        pub pc_rating: i32,
        pub pc_provisional: bool,
        pub _params: Vec<SetParam>,
    }
    impl Create {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
            client.user().create(
                self.name,
                self.ttt_rating,
                self.ttt_provisional,
                self.uttt_rating,
                self.uttt_provisional,
                self.c_4_rating,
                self.c_4_provisional,
                self.pc_rating,
                self.pc_provisional,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<SetParam> {
            self._params.extend([
                name::set(self.name),
                ttt_rating::set(self.ttt_rating),
                ttt_provisional::set(self.ttt_provisional),
                uttt_rating::set(self.uttt_rating),
                uttt_provisional::set(self.uttt_provisional),
                c_4_rating::set(self.c_4_rating),
                c_4_provisional::set(self.c_4_provisional),
                pc_rating::set(self.pc_rating),
                pc_provisional::set(self.pc_provisional),
            ]);
            self._params
        }
    }
    pub fn create(
        name: String,
        ttt_rating: i32,
        ttt_provisional: bool,
        uttt_rating: i32,
        uttt_provisional: bool,
        c_4_rating: i32,
        c_4_provisional: bool,
        pc_rating: i32,
        pc_provisional: bool,
        _params: Vec<SetParam>,
    ) -> Create {
        Create {
            name,
            ttt_rating,
            ttt_provisional,
            uttt_rating,
            uttt_provisional,
            c_4_rating,
            c_4_provisional,
            pc_rating,
            pc_provisional,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct CreateUnchecked {
        pub name: String,
        pub ttt_rating: i32,
        pub ttt_provisional: bool,
        pub uttt_rating: i32,
        pub uttt_provisional: bool,
        pub c_4_rating: i32,
        pub c_4_provisional: bool,
        pub pc_rating: i32,
        pub pc_provisional: bool,
        pub _params: Vec<UncheckedSetParam>,
    }
    impl CreateUnchecked {
        pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
            client.user().create_unchecked(
                self.name,
                self.ttt_rating,
                self.ttt_provisional,
                self.uttt_rating,
                self.uttt_provisional,
                self.c_4_rating,
                self.c_4_provisional,
                self.pc_rating,
                self.pc_provisional,
                self._params,
            )
        }
        pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
            self._params.extend([
                name::set(self.name),
                ttt_rating::set(self.ttt_rating),
                ttt_provisional::set(self.ttt_provisional),
                uttt_rating::set(self.uttt_rating),
                uttt_provisional::set(self.uttt_provisional),
                c_4_rating::set(self.c_4_rating),
                c_4_provisional::set(self.c_4_provisional),
                pc_rating::set(self.pc_rating),
                pc_provisional::set(self.pc_provisional),
            ]);
            self._params
        }
    }
    pub fn create_unchecked(
        name: String,
        ttt_rating: i32,
        ttt_provisional: bool,
        uttt_rating: i32,
        uttt_provisional: bool,
        c_4_rating: i32,
        c_4_provisional: bool,
        pc_rating: i32,
        pc_provisional: bool,
        _params: Vec<UncheckedSetParam>,
    ) -> CreateUnchecked {
        CreateUnchecked {
            name,
            ttt_rating,
            ttt_provisional,
            uttt_rating,
            uttt_provisional,
            c_4_rating,
            c_4_provisional,
            pc_rating,
            pc_provisional,
            _params,
        }
    }
    #[derive(Debug, Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByWithRelationParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(ttt_rating::NAME),
                ::prisma_client_rust::sel(ttt_provisional::NAME),
                ::prisma_client_rust::sel(uttt_rating::NAME),
                ::prisma_client_rust::sel(uttt_provisional::NAME),
                ::prisma_client_rust::sel(c_4_rating::NAME),
                ::prisma_client_rust::sel(c_4_provisional::NAME),
                ::prisma_client_rust::sel(pc_rating::NAME),
                ::prisma_client_rust::sel(pc_provisional::NAME),
            ]
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "name")]
        pub name: name::Type,
        #[serde(rename = "tttRating")]
        pub ttt_rating: ttt_rating::Type,
        #[serde(rename = "tttProvisional")]
        pub ttt_provisional: ttt_provisional::Type,
        #[serde(rename = "utttRating")]
        pub uttt_rating: uttt_rating::Type,
        #[serde(rename = "utttProvisional")]
        pub uttt_provisional: uttt_provisional::Type,
        #[serde(rename = "c4Rating")]
        pub c_4_rating: c_4_rating::Type,
        #[serde(rename = "c4Provisional")]
        pub c_4_provisional: c_4_provisional::Type,
        #[serde(rename = "pcRating")]
        pub pc_rating: pc_rating::Type,
        #[serde(rename = "pcProvisional")]
        pub pc_provisional: pc_provisional::Type,
    }
    impl Data {}
    #[macro_export]
    macro_rules ! _partial_unchecked_user { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: user struct $ struct_name { # [serde (rename = "name")] pub name : String , # [serde (rename = "tttRating")] pub ttt_rating : i32 , # [serde (rename = "tttProvisional")] pub ttt_provisional : bool , # [serde (rename = "utttRating")] pub uttt_rating : i32 , # [serde (rename = "utttProvisional")] pub uttt_provisional : bool , # [serde (rename = "c4Rating")] pub c_4_rating : i32 , # [serde (rename = "c4Provisional")] pub c_4_provisional : bool , # [serde (rename = "pcRating")] pub pc_rating : i32 , # [serde (rename = "pcProvisional")] pub pc_provisional : bool } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_user as partial_unchecked;
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
    pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
    pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
            FindUniqueQuery::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
            FindFirstQuery::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
            FindManyQuery::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            ttt_rating: i32,
            ttt_provisional: bool,
            uttt_rating: i32,
            uttt_provisional: bool,
            c_4_rating: i32,
            c_4_provisional: bool,
            pc_rating: i32,
            pc_provisional: bool,
            mut _params: Vec<SetParam>,
        ) -> CreateQuery<'a> {
            _params.extend([
                name::set(name),
                ttt_rating::set(ttt_rating),
                ttt_provisional::set(ttt_provisional),
                uttt_rating::set(uttt_rating),
                uttt_provisional::set(uttt_provisional),
                c_4_rating::set(c_4_rating),
                c_4_provisional::set(c_4_provisional),
                pc_rating::set(pc_rating),
                pc_provisional::set(pc_provisional),
            ]);
            CreateQuery::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            ttt_rating: i32,
            ttt_provisional: bool,
            uttt_rating: i32,
            uttt_provisional: bool,
            c_4_rating: i32,
            c_4_provisional: bool,
            pc_rating: i32,
            pc_provisional: bool,
            mut _params: Vec<UncheckedSetParam>,
        ) -> CreateUncheckedQuery<'a> {
            _params.extend([
                name::set(name),
                ttt_rating::set(ttt_rating),
                ttt_provisional::set(ttt_provisional),
                uttt_rating::set(uttt_rating),
                uttt_provisional::set(uttt_provisional),
                c_4_rating::set(c_4_rating),
                c_4_provisional::set(c_4_provisional),
                pc_rating::set(pc_rating),
                pc_provisional::set(pc_provisional),
            ]);
            CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
            let data = data.into_iter().map(CreateUnchecked::to_params).collect();
            CreateManyQuery::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
            UpdateQuery::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> UpdateUncheckedQuery<'a> {
            UpdateUncheckedQuery::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateManyQuery<'a> {
            UpdateManyQuery::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            _create: Create,
            _update: Vec<SetParam>,
        ) -> UpsertQuery<'a> {
            UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
            DeleteQuery::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
            DeleteManyQuery::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
            CountQuery::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn game(&self) -> super::game::Actions {
            super::game::Actions { client: &self.0 }
        }
        pub fn user(&self) -> super::user::Actions {
            super::user::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum GameScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "createdAt")]
        CreatedAt,
        #[serde(rename = "rated")]
        Rated,
        #[serde(rename = "gameKey")]
        GameKey,
        #[serde(rename = "gameName")]
        GameName,
        #[serde(rename = "clockInitial")]
        ClockInitial,
        #[serde(rename = "clockIncrement")]
        ClockIncrement,
        #[serde(rename = "firstName")]
        FirstName,
        #[serde(rename = "firstProvisional")]
        FirstProvisional,
        #[serde(rename = "firstRating")]
        FirstRating,
        #[serde(rename = "secondName")]
        SecondName,
        #[serde(rename = "secondProvisional")]
        SecondProvisional,
        #[serde(rename = "secondRating")]
        SecondRating,
        #[serde(rename = "ratingMin")]
        RatingMin,
        #[serde(rename = "ratingMax")]
        RatingMax,
        #[serde(rename = "startPos")]
        StartPos,
        #[serde(rename = "moves")]
        Moves,
        #[serde(rename = "firstTime")]
        FirstTime,
        #[serde(rename = "secondTime")]
        SecondTime,
        #[serde(rename = "status")]
        Status,
    }
    impl ToString for GameScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "createdAt".to_string(),
                Self::Rated => "rated".to_string(),
                Self::GameKey => "gameKey".to_string(),
                Self::GameName => "gameName".to_string(),
                Self::ClockInitial => "clockInitial".to_string(),
                Self::ClockIncrement => "clockIncrement".to_string(),
                Self::FirstName => "firstName".to_string(),
                Self::FirstProvisional => "firstProvisional".to_string(),
                Self::FirstRating => "firstRating".to_string(),
                Self::SecondName => "secondName".to_string(),
                Self::SecondProvisional => "secondProvisional".to_string(),
                Self::SecondRating => "secondRating".to_string(),
                Self::RatingMin => "ratingMin".to_string(),
                Self::RatingMax => "ratingMax".to_string(),
                Self::StartPos => "startPos".to_string(),
                Self::Moves => "moves".to_string(),
                Self::FirstTime => "firstTime".to_string(),
                Self::SecondTime => "secondTime".to_string(),
                Self::Status => "status".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserScalarFieldEnum {
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "tttRating")]
        TttRating,
        #[serde(rename = "tttProvisional")]
        TttProvisional,
        #[serde(rename = "utttRating")]
        UtttRating,
        #[serde(rename = "utttProvisional")]
        UtttProvisional,
        #[serde(rename = "c4Rating")]
        C4Rating,
        #[serde(rename = "c4Provisional")]
        C4Provisional,
        #[serde(rename = "pcRating")]
        PcRating,
        #[serde(rename = "pcProvisional")]
        PcProvisional,
    }
    impl ToString for UserScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Name => "name".to_string(),
                Self::TttRating => "tttRating".to_string(),
                Self::TttProvisional => "tttProvisional".to_string(),
                Self::UtttRating => "utttRating".to_string(),
                Self::UtttProvisional => "utttProvisional".to_string(),
                Self::C4Rating => "c4Rating".to_string(),
                Self::C4Provisional => "c4Provisional".to_string(),
                Self::PcRating => "pcRating".to_string(),
                Self::PcProvisional => "pcProvisional".to_string(),
            }
        }
    }
    impl Into<::prisma_client_rust::PrismaValue> for SortOrder {
        fn into(self) -> ::prisma_client_rust::PrismaValue {
            match self {
                SortOrder::Asc => ::prisma_client_rust::PrismaValue::String("asc".to_string()),
                SortOrder::Desc => ::prisma_client_rust::PrismaValue::String("desc".to_string()),
            }
        }
    }
    pub mod read_filters {
        #[derive(Debug, Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BooleanFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BooleanNullableFilter {
            Equals(Option<bool>),
            Not(Option<bool>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum IntNullableFilter {
            Equals(Option<i32>),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(Option<i32>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum GameStatusFilter {
            Equals(super::super::GameStatus),
            InVec(Vec<super::super::GameStatus>),
            NotInVec(Vec<super::super::GameStatus>),
            Not(super::super::GameStatus),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for GameStatusFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
    }
    pub mod write_params {
        #[derive(Debug, Clone)]
        pub enum StringParam {
            Set(String),
        }
        impl Into<::prisma_client_rust::PrismaValue> for StringParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::String(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum StringNullableParam {
            Set(Option<String>),
        }
        impl Into<::prisma_client_rust::PrismaValue> for StringNullableParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum DateTimeParam {
            Set(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::PrismaValue> for DateTimeParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::DateTime(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BooleanParam {
            Set(bool),
        }
        impl Into<::prisma_client_rust::PrismaValue> for BooleanParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::Boolean(value),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum BooleanNullableParam {
            Set(Option<bool>),
        }
        impl Into<::prisma_client_rust::PrismaValue> for BooleanNullableParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => value
                        .map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum IntParam {
            Set(i32),
            Increment(i32),
            Decrement(i32),
            Multiply(i32),
            Divide(i32),
        }
        impl Into<::prisma_client_rust::PrismaValue> for IntParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::Int(value as i64),
                    Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum IntNullableParam {
            Set(Option<i32>),
            Increment(i32),
            Decrement(i32),
            Multiply(i32),
            Divide(i32),
        }
        impl Into<::prisma_client_rust::PrismaValue> for IntNullableParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Debug, Clone)]
        pub enum GameStatusParam {
            Set(super::super::GameStatus),
        }
        impl Into<::prisma_client_rust::PrismaValue> for GameStatusParam {
            fn into(self) -> ::prisma_client_rust::PrismaValue {
                match self {
                    Self::Set(value) => ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                }
            }
        }
    }
}
pub use _prisma::*;
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum GameStatus {
    #[serde(rename = "WAITING")]
    Waiting,
    #[serde(rename = "STARTED")]
    Started,
}
impl ToString for GameStatus {
    fn to_string(&self) -> String {
        match self {
            Self::Waiting => "WAITING".to_string(),
            Self::Started => "STARTED".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum Side {
    #[serde(rename = "FIRST")]
    First,
    #[serde(rename = "SECOND")]
    Second,
    #[serde(rename = "RANDOM")]
    Random,
}
impl ToString for Side {
    fn to_string(&self) -> String {
        match self {
            Self::First => "FIRST".to_string(),
            Self::Second => "SECOND".to_string(),
            Self::Random => "RANDOM".to_string(),
        }
    }
}
